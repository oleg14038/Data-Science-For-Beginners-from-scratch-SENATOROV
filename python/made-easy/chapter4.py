"""Chapter4."""

# +
import math

import numpy as np

# import random
# -

# 4.1 . Переменные

# Переменные в Python - это просто указатели. Сами по себе они не имеют значе
#
# ний, а просто указывают на объект, который им присвоен. Технически перемен
#
# ные - это просто области в памяти вашего компьютера, в которых хранится неко
#
# торая информация. Значения переменных, как следует из самого слова «перемен
#
# ная», могут меняться. То есть вы можете хранить что угодно в переменной.

x_num = 38

email = "olegnefedov385@gmail.com"

print(x_num)
print(email)
print(type(x_num))
print(type(email))

# 4.1 . 1 . Оператор п рисваивания
# Когда мы вводим переменную вида х = 38, то в этой записи х - это имя перемен
# ной, (=) - это оператор присваивания, а 38 - это присвоенное значение.
# Здесь, в отличие от арифметики, знак (=) не означает «равно». Он означает
# «при
# своить». В Python «равно» записывается как ==. Мы увидим это позже, когда
# будем
# изучать операторы сравнения.

# 4.1.2. Имена переменных
#
# ♦ Имена переменных могут содержать только буквы, цифры и нижние подчерки
# вания.
#
# ♦ Несмотря на то что числа использовать можно, имя не должно начинаться с чис
# ла. Имя S fingers недопустимо.
#
# ♦ В имени нельзя использовать пробелы. Имя sales data недопустимо. Зато можно
# написать sales data.
#
# ♦ Имена чувствительны к регистру. Sales и sales - это две разные переменные.
#
# ♦ Наконец, имена переменных не могут совпадать с ключевыми словами. Эrо за
# резервированные слова, которые для интерпретатора Python имеют особый
# смысл, например and, break и try.
# Чтобы получить список ключевых слов, можно запустить вот такой код, который и
# выведет список ключевых слов.

# Чтобы получить список ключевых слов, можно запустить вот такой код, который и
# выведет список ключевых слов

#
# import keyword

# print(keyword.kwlist)

# 4.2. Структура программы
#
# Прежде чем двигаться дальше, давайте разберем иерархическую структуру про
#
# граммы. Не пугайтесь новых слов, поскольку мы подробно изучим их позже.
#
# В программе на Python можно выделить такие части, как модули, выражения,
# операторы и объекты

# Программы состоят из модулей.
#
# Модули содержат выражения.
#
# Выражения содержат операторы.
#
# Объекты и операторы в Python
#
# Операторы создают и обрабатывают объекты.
#
# Итак, модули находятся на вершине иерархии программы, а объекты составляют ее
# основу. Начнем снизу. Давайте рассмотрим встроенные объекты и выражения,
# с помощью которых можно работать с этими объектами

# 4.3. Объекты
# Если говорить просто, в Python мы выполняем операции над объектами.
#
# Примерами простых операций являются сложение, умножение чисел (как объектов)
# или конкатенация строк (как объектов).
#
# В Python все данные становятся объектами. Объекты могут быть либо встроенны
# ми, которые есть в Python изначально, либо мы создаем их сами с помощью
# классов Python.
#
# Для понимания того, что такое объект, нам пока будет достаточно знать, что
# это просто «фрагмент памяти», содержащий значение, а также некоторые
# связанные с объектом операции

# Каждый объект имеет уникальный идентификатор, который фактически является
# адресом объекта в памяти.
#
# Идентификатор можно получить с помощью функции id()

# 4.3. 1 .Классификация объектов
# Объекты делятся по типу данных на:
#
# ♦ встроенные;
#
# ♦ пользовательские.
#
# Типы данных также бывают:
#
# ♦ изменяемые;
#
# ♦ неизменяемые.

# Тип объекта Примеры объектов Изменяемый или
# неизменяемый?
#
# Числа 1234, 3 . 1 4 1 5, 3+4j , OЫ l l, Decimal () , Fraction()- Неизменяемый
#
# Строки ' nilabh ' , "Bob ' s " Неизменяемый
#
# Списки [ 1 , [ 2 , ' three ' ] , 4 . 5 ] , list ( range ( lO) ) Изменяемый
#
# Словари {' food ' : ' spam' , ' taste ':'yum'} , dict (hours:1 0 ) Изменяемый
#
# Кортежи ( 1 , ' spam' , 4 , ' U ' ) , tuple { ' spam' ) Неизменяемый
#
# Множества set ( ' аЬс ' ) , { ' а ' , ' Ь ' , ' с ' } Изменяемый
#
# Логический тип О, 1 Неизменяемый
#
# Компоненты Функции, модули, классы

# 4.3.3. Идентифи каторы, значения и типы объектов

# Объекты - это абстракция данных Python. Любые данные в программе Python
# представлены либо объектами, либо отношениями между объектами.
# Объект можно представить как сочетание трех вещей:
#
# ♦ идентификатор;
#
# ♦ тип данных;
#
# ♦ значение.

a_nane = 5
print(id(a_nane))
print(type(a_nane))

# type ( ' Nilabh ' ) # str означает строку
#
# tуре ( З . 5 )# число с плавающей точкой
#
# type ( [ ' x ' , ' yz ' , ' аЬс ' ] ) # список, содержащий три строк
#
# type ( [ ' x ' , ' у ' , 1 ] ) # список из двух строк и одного числа
#
# type ( { ' food ' : ' spam ' , ' taste ' : ' yum ' } ) # словарь

# 4.3.4. Изменяемые и неизменяемые объекты

# Что такое ссылка на объект?
#
# Когда вы создаёте переменную и присваиваете ей значение, переменная не хранит
#
# само значение. Вместо этого она содержит ссылку на область памяти, где это
#
# значение находится. Это особенно важно при работе с изменяемыми объектами,
#
# такими как списки и словари.

a_num = [1, 2, 3]  # Список создаётся в памяти, а 'a' ссылается на него
b_num = a_num  # 'b' теперь содержит ссылку на тот же самый список
print(id(a_num))
print(id(b_num))
b_num[0] = 100  # Изменяем список через переменную 'b'
print(a_num)  # Вывод: [100, 2, 3] — изменения отразились и в 'a'

# Объяснение:
#
#     Когда вы присваиваете b = a, обе переменные начинают ссылаться на один и
# тот же объект (список [1, 2, 3]).
#     Изменение через переменную b приводит к изменению объекта, на который
# ссылается и a, так как это один и тот же объект в памяти.

# Ссылки в изменяемых и неизменяемых объектах
#
#     Изменяемые объекты (mutable objects): списки (list), словари (dict),
#  множества (set) и объекты классов могут изменяться по ссылке.

x_number = [1, 2, 3]
y_num = x_number
y_num.append(4)
print(x_number)  # [1, 2, 3, 4] — список изменился через ссылку 'y_num'
print(y_num)

# Неизменяемые объекты (immutable objects): строки (str), числа (int, float),
#
# кортежи (tuple) не могут быть изменены напрямую. Если вы пытаетесь их
#
# изменить, создаётся новый объект, а переменная просто перенаправляется

# +
x_numb = 10
y_number = x_numb

print(y_number)

y_number += 5  # создаётся новый объект '15'
print(x_numb)  # 10 — 'x' осталась ссылаться на прежний объект

# Вложенные ссылки
# Объекты могут содержать ссылки на другие объекты. Например, списки могут
# хранить другие списки или словари, которые, в свою очередь, могут ссылаться
# на другие объекты

# +
a_b = [1, [2, 3], 4]  # Список содержит другой список
b_a = a_b[1]  # 'b' содержит ссылку на список [2, 3]

print(b_a)

# b_a[2] = 200  # Изменение вложенного списка через 'b_a'
print(a_b)  # [1, [200, 3], 4] — изменения отражаются в исходном списке

# Особенность Python: подсчёт ссылок и сборщик мусора
#
# Python использует механизм подсчёта ссылок для управления памятью. Каждый
# объект хранит количество ссылок на него. Когда счётчик ссылок объекта
# становится равным нулю, объект может быть удалён сборщиком мусора.
# import sys  # Импортируем модуль в начале файла

# x_gen = [1, 2, 3]
# print(sys.getrefcount(x_gen))  # Выводит количество ссылок на объект x_gen
# -

# 4.4. Стандартная иерархия типов

# 4.4.1 . Встроенные константы

# None
# У этого типа данных одно-единственное значение. И есть только один объект
#
# с таким значением. Доступ к этому объекту осуществляется через встроенное
#
# имя None. Он используется для обозначения отсутствия значения, например воз
#
# вращается из функций, которые ничего явно не возвращают. В логическом
#
# смысле эквивалентен False

# Числовые методы и методы сравнения должны возвращать этот
# объект, если они не реализуют операцию для предоставленных операндов. В ло
# гическом смысле эквивалентен True.

# Ellipsis
# У этого типа одно-единственное значение. И это единственный объект с таким
# значением. Доступ к этому объекту осуществляется через литерал . . .
# или встро
# енное имя Ellipsis. В логическом смысле эквивалентен тrue.

# Заполнитель в функциях: Эллипсис может использоваться как заполнитель в
# функциях, когда вы планируете добавить код позже:


def some_function() -> None:
    """Выполняет действие без возврата значения."""


# Срезы в многомерных массивах: Эллипсис полезен при работе с многомерными
# массивами, например, в библиотеке NumPy. Он позволяет упростить код, заменяя
# несколько двоеточий (:):

# +
arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

print(arr[..., 1])  # Вывод: [[ 2  5]
#         [ 8 11]]


# +
# Аргументы функций: Эллипсис может использоваться для указания переменного
# количества аргументов в функции:
# +
def print_args(x_y: int, y_x: int, z_x: int, *args: int) -> None:
    """Выводит значения аргументов x, y, z.

    И дополнительные аргументы args.
    """
    print(f"x = {x_y}, y = {y_x}, z = {z_x}, args = {args}")


# Вызов функции с позиционными аргументами
print_args(1, 2, 3, 4, 5, 6)  # Вывод: x = 1, y = 2, z = 3, args = (4, 5, 6)

# Аннотации типов: В Python 3.10 и выше, эллипсис можно использовать в
# аннотациях типов для указания, что функция может принимать аргументы любого
# типа:

# from typing import List

# def process_data(data: List[...]) -> ...:
#     ...
# -

# Списковые выражения: Эллипсис может использоваться в списковых выражениях
#  для создания последовательностей с пропущенными элементами:

my_list = [x_x if x_x % 2 == 0 else ... for x_x in range(10)]
print(my_list)  # Вывод: [0, ..., 2, ..., 4, ..., 6, ..., 8, ...]

# 4.4.2. Числовые типы

# Целые числа (int)
# Это целые числа в неограниченном диапазоне, зависящем только от доступной
# (виртуальной) памяти. Для операций сдвига и маски используется двоичное
# представление, а отрицательные числа представлены в дополнительном коде,
# что создает иллюзию бесконечной строки знаковых битов, простирающейся
# влево

# Логические значения (Ьооl)
# Единственными логическими объектами являются тrue и False, представляющие
# логические значения. Логический тип является подтипом целочисленного, т. к.
# логические значения ведут себя как значения О и 1 почти во всех случаях, за
# ключением того, что при преобразовании в строку возвращаются строки "True"
# и " False" соответственно.

# Вещественные числа (float)
# Это числа с плавающей точкой двойной точности машинного уровня. Здесь диа
# пазон значений и обработка переполнений задаются на уровне базовой машиной
# архитектуры (и реализации С или Java). Python не поддерживает числа
# с плавающей точкой одинарной точности, т. к. экономия на ресурсах процессора
# и памяти, которая обычно является причиной их использования, перекрывается
# накладными расходами на использование объектов в Python, поэтому нет при
# чин усложнять язык двумя видами чисел с плавающей точкой.

# Комплексные числа в Python являются встроенным типом данных и могут быть
# представлены в виде a + bj, где a — действительная часть, а b — мнимая часть.
#
# Здесь j обозначает мнимую единицу, аналогично математической записи, где
# обычно используется i.
#
# Вот основные моменты о работе с комплексными числами в Python:

# +
z_one = 3 + 4j  # Здесь 3 — действительная часть, 4 — мнимая часть

RealPart = z_one.real  # Действительная часть: 3.0
ImagPart = z_one.imag  # Мнимая часть: 4.0

print(f"Действительная часть: {RealPart}, Мнимая часть: {ImagPart}")

# +
z1 = 1 + 2j
z2 = 3 + 4j
z_sum = z1 + z2  # (1 + 3) +
# (2 + 4)j = 4 + 6j

z_diff = z1 - z2  # (1 - 3) +
# (2 - 4)j = -2 - 2j

z_product = z1 * z2  # (1 * 3 - 2 * 4) +
# (1 * 4 + 2 * 3)j = -5 + 10j

z_quotient = z1 / z2  # ((1 * 3 + 2 * 4) /
# (3^2 + 4^2)) + ((2 * 3 - 1 * 4) / (3^2 + 4^2))j


print(f"{z_sum}\n{z_diff}\n{z_product}\n{z_quotient}")

# 4.4.3. Последовательности
# Это конечные упорядоченные множества с индексацией неотрицательными
# числами.
# Встроенная функция len ( ) возвращает количество элементов последователь
# ности. Когда длина последовательности равна п, ее индексы лежат в диапазоне
# О, 1 , ... , п - 1
#
# Чтобы выбрать i-й элемент последовательности а, нужно напи
# сать a [ i J .
#
# Последовательности также поддерживают операции срезов. Срез а [ i : j J
# выбираетвсе элементы с таким индексом k, что выполняется неравенство
# i <= k < j .
#
# При использовании в выражении срез представляет собой последовательность
# того жетипа.
#
# Это означает, что сам по себе срез тоже проиндексирован с О.
# Некоторые последовательности также поддерживают «расширенные срезы»
# с третьим параметром - шагом.
#
# Срез a [ i : j : k] выбирает все элементы а с индек
# сом х, где выполняются условия: х = i + n * k, n >= О и i <= х < j .
# Последовательности можно разделить на группы по признаку изменяемости

# 4.4.3. 1 . Неизменяемые последовательности

# 4.4.3. 1 . Неизменяемые последовательности
# Неизменяемые последовательности не могут быть изменены после создания. Если
# объект содержит ссылки на другие объекты, то эти другие объекты могут изме
# няться, но коллекция объектов, на которые ссылается эта неизменяемая последо
# вальность, измениться не может.

# ♦ Строки (str)
# Строка - это последовательность значений, кодируемых таблицей Un icode.
#
# В Python нет типа char, а символы представляются как строки длиной 1 .
#
# Строки в Python заключаются в одинарные или двойные кавычки. Строки
# ' привет ' и "привет" идентичны.
# Любые символы в диапазоне кодов от u+oooo до U+l OFFFF могут быть представле
# ны в виде строки.

# Встроенная функция ord ( ) переводит код символа из строковой формы в целое
# число в диапазоне от о до l0FFFF, а функция chr ( ) преобразует целое число
# в диапазоне от о до l 0 FFFF в соответствующий строковый объект длиной 1 .

# +
b_s = "nilabh"  # строка, символ ' n ' находится на 0-м индексе,
# а ' h ' - на 5-м

print(b_s[3])  # срез строки по индексу 3 дает "а"

# Получаем код для символа 'A'
code_a = ord("A")
print(code_a)  # Вывод: 65

# Получаем код для символа 'a'
code_a_lower = ord("a")
print(code_a_lower)  # Вывод: 97

# Получаем код для символа '1'
code_one = ord("1")
print(code_one)  # Вывод: 49

# Получаем код для символа '!'
code_exclamation = ord("!")
print(code_exclamation)  # Вывод: 33

# +
# Получаем символ для кодовой точки 65
char_a = chr(65)
print(char_a)  # Вывод: 'A'

# Получаем символ для кодовой точки 97
char_a_lower = chr(97)
print(char_a_lower)  # Вывод: 'a'

# Получаем символ для кодовой точки 49
char_one = chr(49)
print(char_one)  # Вывод: '1'

# Получаем символ для кодовой точки 33
char_exclamation = chr(33)
print(char_exclamation)  # Вывод: '!'

# Кортежи (tuple)
# Элементами кортежа могут быть любые объекты Python. Кортеж из двух или
# более элементов формируется из списка выражений, разделенных запятыми.
# Кортеж из одного элемента можно создать путем добавления запятой к выраже
# нию (выражение само по себе не является кортежем, а для группировки выраже
# ний в кортеж необходимо использовать круглые скобки). Пустой кортеж можно
# задать пустой парой круглых скобок.
#
# Пример кортежа: ( ' xyz ' , 5, ' р ' ) .

# ♦ Байтовые строки (Ьytes)
#
# Объекты и операторы в Python \ 121
#
# Объект типа bytes - это неизменяемый массив. Его элементы представляют со
# бой 8-битные числа х, такие что о <= х < 256. Для создания байтовых строк мож
# но использовать байтовые литералы (например, Ь ' аЬс ' ) или встроенный конст
# руктор bytes ()  Кроме того, байтовые строки можно декодировать в строки с по
# мощью метода decode ( )

# Создание байтовой строки с помощью литерала
byte_str = b"Hello, World!"
print(byte_str)  # Вывод: b'Hello, World!'

# Использование функции bytes():
# Создание байтовой строки с помощью функции bytes()

byte_str_from_list = bytes([72, 101, 108, 108, 111])
# ASCII-коды для 'Hello'

print(byte_str_from_list)  # Вывод: b'Hello'

# 4.4.3.2. Изменяемые последовательности

# Списки (list)
# Элементами списка могут быть произвольные объекты Python. Списки форми
# руются путем передачи списка выражений, разделенных запятыми, заключенно
# го в квадратные скобки (обратите внимание, что для формирования списков
# длины О или 1 особых обозначений не требуется).
# Пример списка:
#
# [ ' xyz ' , 5, ' р ' ] .
#
# ♦ Байтовые массивы (Ьytea.rray)
# Объект bytearray - это изменяемый массив. Такие массивы создаются встроен
# ным конструктором bytearray ( ) . Кроме того, что байтовые массивы являются
# изменяемыми (и, следовательно, нехешируемыми), у них тот же интерфейс и
# функциональность, что и у неизменяемых байтовых объектов.
#
# Байтовые массивы (bytearrays) в Python представляют собой изменяемые
# последовательности байтов

# Создание байтового массива с начальным содержимым
byte_array_with_data = bytearray([65, 66, 67])

# ASCII-коды для 'A', 'B', 'C'
print(byte_array_with_data)  # Вывод: bytearray(b'ABC')
# -

# Множества (set)
# Это изменяемые множества. Они создаются встроенным конструктором set ( )
# и впоследствии могут быть изменены некоторыми методами, такими как add ( ) .
#
# Пример множества: { "apple" , "banana" , "cherry" ) .
#
# ♦ Замороженные множества (frozenset)
# Это неизменяемые множества. Они создаются встроенным конструктором
# frozenset ( ) . Поскольку этот тип является неизменяемым и хешируемым, его
# можно включать в другие множества или использовать в качестве ключа сло
# варя.

# 4.4.5. Сопоставления

# Сопоставления представляют собой конечные наборы объектов, индексированных
# произвольными индексами. Обращение вида а [kJ позволяет выбрать из сопоставле
# ния а элемент с индексом k. Этот синтаксис можно использовать в выражениях,
# в операторах присваиваний и в операторах del.Встроенная функция len () возвра
# щает количество элементов в сопоставлении.
# В настоящее время в языке Python существует один тип сопоставления

# Словарь (dict)
# Словарь представляет собой конечный набор объектов с почти произвольными
# индексами (ключами). В качестве ключей можно использовать все типы, кроме
# типов вроде списков или других словарей, которые являются изменяемыми и
# сравниваются по значению, а не по идентификатору объекта. Все дело в том, что
# для эффективной реализации словарей требуется, чтобы хеш-значения ключей
# не менялись. Числовые типы, используемые в качестве ключей, подчиняются
# обычным правилам числового сравнения: если два числа являются равными ( на
# пример, 1 и 1 .0), то они оба могут использоваться для индексации одного и
# тогоже элемента словаря.
# Словари изменяемы. Создать словарь можно с помощью фигурных скобок { } .
# Пример словаря: {"марка" : "Форд" , "модель " : "Мустанг" , " год" : 1 9 64}

# 4.4.6. Вызываемые типы
# Это типы объектов, к которым может применяться операция вызова функции:
# ♦ Встроенные функции
#
# Функция - это блок кода, который запускается только при ее вызове. В функ
# цию можно передавать параметры. В конце выполнения функция может вернуть
# какие-то данные. Примеры встроенных функций: len ( ) и math. sin ( ) (math -
# это стандартный встроенный модуль).
#
# Чтобы вызвать функцию, нужно написать имя функции, а за ним круглые скоб
# ки. Например, len ( ) - это функция, которая возвращает длину строки

# Пользовательские функции
# Пользовательская функция создается с помощью определения функции (под
# робнее об этом в следующих главах). Функция вызывается со списком аргумен
# тов, в котором должно быть то же количество элементов, что и в списке фор
# мальных параметров функции в определении

# +
# def find_maximum(number_1: int, number_2: int) -> int:
#     """Return the larger of two number.

#     The function compares two integers and returns the larger one.
#     """
#     number_1 = random.randint(1, 5)
#     number_2 = random.randint(1, 5)
#     if number_1 > number_2:
#         result: int = number_1
#         print("The number_1 variable is reassigned to the result variable")

#     else:
#         print("The number_2 variable is reassigned to the result variable")

#     return result

# Методы
# Метод экземпляра объединяет класс, экземпляр класса и любой вызываемый
# объект (обычно пользовательскую функцию).
#
# Методы в Python — это функции, которые принадлежат объектам (например,
# строки, списки, словари). Они позволяют выполнять определённые операции
# с объектами.

# 1. Методы для строк (string)
# Строки — это неизменяемые последовательности символов. Вот несколько
# полезных методов для работы с ними:

text_str = "hello, world"
print(text_str.upper())  # Выведет: HELLO, WORLD

text_one = "hello, world"
new_text = text_one.replace("world", "Python")
print(new_text)  # Выведет: hello, Python

# +
# Пример 3: Метод .strip()

# Удаляет пробелы в начале и конце строки.
text_two = "   hello, world   "
print(text_two.strip())  # Выведет: hello, world
# -

# Методы для списков (list)
#
# Списки — это изменяемые последовательности элементов. Вот несколько полезных
#  методов для работы со списками:

# Пример 4: Метод .append()

# Добавляет элемент в конец списка.

numb = [1, 2, 3]
numb.append(4)
print(numb)  # Выведет: [1, 2, 3, 4]

# Пример 5: Метод .remove()

# Удаляет первое вхождение элемента из списка

fruits = ["apple", "banana", "cherry", "apple"]
fruits.remove("apple")
print(fruits)  # Выведет: ['banana', 'cherry', 'apple']

# +
# Пример 6: Метод .sort()

# Сортирует список по возрастанию.

number = [4, 1, 3, 2]
number.sort()
print(number)  # Выведет: [1, 2, 3, 4]

# 3. Методы для словарей (dictionary)
#
# Словари — это коллекции пар "ключ-значение". Вот методы для работы
# со словарями:

# +
person = {"name": "Alice", "age": 25, "city": "New York"}
print(person.keys())  # Выведет: dict_keys(['name', 'age', 'city'])

# Пример 8: Метод .values()
# Возвращает список всех значений словаря
print(person.values())  # Выведет: dict_values
# (['Alice', 25, 'New York'])

# Пример 9: Метод .items()
# Возвращает список пар "ключ-значение" в виде кортежей.

print(person.items())  # Выведет: dict_items([('name', 'Alice'),
# ('age', 25), ('city', 'New York')])

# 4. Методы для множеств (set)
#
# Множества — это коллекции уникальных элементов. Вот несколько методов для
#  работы с множествами:

# +
# Пример 10: Метод .add()
# Добавляет элемент в множество.

numbers = {1, 2, 3}
numbers.add(4)
print(numbers)  # Выведет: {1, 2, 3, 4}

# Удаляет элемент из множества.
numbers.remove(2)
print(numbers)  # Выведет: {1, 3, 4}

# Пример 12: Метод .union()

# Возвращает объединение двух множеств.

set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1.union(set2)
print(union_set)  # Выведет: {1, 2, 3, 4, 5}
# -

# 5. Методы для объектов типа file
#
# Python поддерживает работу с файлами. Примеры методов для работы с файлами:

# +
# Пример 13: Метод .read()

# Чтение содержимого файла.

# with open('example.txt', 'r') as file:
#     content = file.read()
#     print(content)

# Пример 14: Метод .write()

# Запись данных в файл.

# with open('example.txt', 'w') as file:
#     file.write("Hello, world!")

# Пример 15: Метод .close()

# Закрытие файла (автоматически вызывается при использовании with)

# file = open('example.txt', 'r')
# file.close()

# Встроенные методы
# На самом деле это то же самое, что и встроенные функции. Метод в Python по
# хож на функцию, за исключением того, что он относится к объекту. Вызывая
# метод объекта, мы, вероятно, вносим в этот объект изменения. Таким образом,
# метод принадлежит классу. Примером является метод добавления элемента
# в список append ( )

# В Python существует множество встроенных функций и методов, которые можно
# использовать без необходимости их импорта. Они предоставляют базовую
#  функциональность для выполнения различных операций. Вот некоторые из
# наиболее часто используемых встроенных методов с примерами.

# +
# 1. len()

# Возвращает длину (количество элементов) объекта (например,
#  строки, списка, кортежа, словаря).

# Пример с строкой
text = "Hello"
print(len(text))  # Выведет: 5

# Пример со списком
num = [1, 2, 3, 4, 5]
print(len(num))  # Выведет: 5

# +
# 2. abs()

# Возвращает абсолютное значение числа.

value = -10
print(abs(value))  # Выведет: 10

# +
# 3. sum()

# Возвращает сумму элементов итерируемого
# объекта (например, список или кортеж).

coun = [1, 2, 3, 4, 5]
print(sum(coun))  # Выведет: 15


# 4. min() и max()

# Возвращают минимальное и максимальное значение
# из последовательности или набора чисел

print(min(coun))  # Выведет: 1
print(max(coun))  # Выведет: 9

# +
# 4. min() и max()

# Возвращают минимальное и максимальное
# значение из последовательности или набора чисел.

# +
# 5. round()

# Округляет число до заданного количества
# знаков после запятой (по умолчанию до ближайшего целого).

constant_value = 3.14159
print(round(constant_value, 2))  # Выведет: 3.14

# Округление до ближайшего целого
# print(round(5.6))  # Выведет: 6

# +
# 6. type()

# Возвращает тип объекта.

obj = 42
print(type(obj))  # Выведет: <class 'int'>

text_three = "Hello"
print(type(text_three))  # Выведет: <class 'str'>

# 7. isinstance()

# Проверяет, принадлежит ли объект
# к определённому типу данных

print(isinstance(obj, int))  # Выведет: True
print(isinstance(text_three, str))  # Выведет: True

# +
# 8. enumerate()

# Возвращает объект, который генерирует кортежи,
# содержащие индекс и соответствующий элемент последовательности.

fruits = ["apple", "banana", "cherry"]
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")

# Выведет:
# 0: apple
# 1: banana
# 2: cherry

# +
# 9. zip()

# Объединяет несколько итерируемых объектов (например, списки)
# в кортежи, где первый элемент каждого кортежа будет взят
# из соответствующего итерируемого объекта.

names = ["Alice", "Bob", "Charlie"]
scores = [85, 90, 95]

for name, score in zip(names, scores):
    print(f"{names}: {score}")

# Выведет:
# Alice: 85
# Bob: 90
# Charlie: 95

# +
# 10. sorted()

# Возвращает отсортированную версию итерируемого объекта
# (например, список), не изменяя оригинал.

numbers_val = [5, 2, 9, 1, 5, 6]
sorted_numbers = sorted(numbers_val)
print(sorted_numbers)  # Выведет: [1, 2, 5, 5, 6, 9]

# Оригинальный список не изменён
print(numbers_val)  # Выведет: [5, 2, 9, 1, 5, 6]
# -

# 11. all() и any()
# all() возвращает True, если все элементы итерируемого объекта истинные.
# any() возвращает True, если хотя бы один элемент итерируемого объекта
# истинный.
# +
# Пример с all()
# print(all([True, True, False]))  # Выведет: False

# # Пример с any()
# print(any([False, False, True]))  # Выведет: True

# +
# 13. filter()

# Фильтрует элементы итерируемого объекта на основе функции,
# которая возвращает True или False.

numbers_one = [1, 2, 3, 4, 5, 6]

# Оставляем только чётные числа
even_numbers = filter(lambda x: x % 2 == 0, numbers_one)
print(list(even_numbers))  # Выведет: [2, 4, 6]

# +
# # 15. eval()

# # Выполняет строковое выражение как Python-код.
# # Будьте осторожны при использовании eval(),
# # так как оно может быть небезопасным

# expression = "2 + 3 * 5"
# result_3 = eval(expression)
# print(result_3)  # Выведет: 17

# +
# # 16. open()

# # Открывает файл для чтения или записи.

# # Открываем файл для записи
# with open('example.txt', 'w') as file:
#     file.write("Hello, World!")

# # Открываем файл для чтения
# with open('example.txt', 'r') as file:
#     content = file.read()
#     print(content)  # Выведет: Hello, World!
# -

# ♦ Классы
# Классы относятся к вызываемым объектам и объединяют в себе данные и функ
# циональность. Создание нового класса позволяет создать новый тип объектов, а
# в дальнейшем и новые экземпляры этого типа. Каждый экземпляр класса хранит
# атрибуты, определяющие его состояние. Экземпляр класса также может иметь
# методы (определяемые этим классом), изменяющие его состояние.

# Классы в Python — это конструкции, позволяющие создавать пользовательские
#  объекты, которые могут содержать как данные (атрибуты), так и функции
# (методы). Они позволяют организовать код и облегчить его повторное
# использование.
# +
# 1. Простой класс
# Пример 1: Класс Dog


class Dog:
    """Класс для представления собак."""

    def __init__(self, name_dog: str, age_dog: int):
        """Инициализация атрибутов собаки."""
        self.name_dog: str = name_dog
        self.age_dog: int = age_dog

    def bark(self) -> str:
        """Издает лай."""
        return f"{self.name_dog} говорит: Гав!"


# Создание экземпляра класса
my_dog = Dog("Бобик", 3)

# Вызов метода
print(my_dog.bark())  # Выведет: Бобик говорит: Гав!

# +
# Пример 2: Класс Circle


class Circle:
    """Класс для представления круга."""

    def __init__(self, radius: float):
        """Инициализация радиуса круга."""
        self.radius = radius

    def area(self) -> float:
        """Возвращает площадь круга."""
        return math.pi * (self.radius**2)

    def circumference(self) -> float:
        """Возвращает длину окружности."""
        return 2 * math.pi * self.radius


# Создание экземпляра класса
circle = Circle(10)

# Вызов методов
print(f"Площадь круга: {circle.area():.2f}")  # Выведет: Площадь круга: 78.54
print(
    f"Длина окружности: {circle.circumference():.2f}",
)  # Выведет: Длина окружности: 31.42
# -

# 4.4.7. Модули
# В целом модуль - это то же самое, что и библиотека кода, т. е. файл с набором
# функций, которые вы хотите добавить в свое приложение. Чтобы создать модуль,
# достаточно лишь сохранить нужный код в файле с расширением ру.
# После этого вновь созданный модуль можно импортировать с помощью оператора
# import.
# Модуль может содержать функции, а также переменные всех типов (массивы, сло
# вари и т. д.)

# 4.5. Операции с объектами в Python

# +
# 14 + 26 # целочисленное сложение
