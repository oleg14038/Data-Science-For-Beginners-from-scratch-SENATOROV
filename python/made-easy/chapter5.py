# +
"""from typing import List: для работы с типами списков."""

# Операторы управления потоком

# Оператор if
#
# Оператор for (цикл)
#
# Оператор while (цикл)
#
# Операторы break и continue
#
# Блок else в циклах
#
# Оператор раss
#
# Операторы управления потоком

# 5.2. Операторы if
#
#
# Оператор if используется для проверки условия и, если условие истинно, выполняется связанный с оператором блок кода (называемый блоком if)

# if условие:
#     # блок кода, который выполнится, если условие истинно
# elif другое_условие:
#     # блок кода, который выполнится, если первое условие ложное и другое условие истинно
# else:
#     # блок кода, который выполнится, если все условия ложные

x_one = 4
if x_one > 0:
    if x_one % 2 == 0:
        print("x_one положительное четное число")
    else:
        print("x_one положительное нечетное число")
else:
    print("x_one отрицательное число")

# +
x_two = 8

# Упрощенное сравнение
if 5 < x_two < 10:
    print("x_two находится между 5 и 10")
    # Оба условия проверяются одновременно

if x_two < 3 or x_two > 7:
    print(
        "x_two меньше 3 или больше 7",
    )  # Достаточно, чтобы одно из условий было истинным
# -

# x_three = 10
# result = "больше 5" if x_three > 5 else "меньше или равен 5"
# print(result)  # Выведет: больше 5

# Синтаксис: ключевое слово if, условие и
# двоеточие. Блок кода оператора if начинается со следующей строки и должен иметь отступ.
#
# Отступ сообщает Python
# о том, что этот блок кода предназначен для оператора if.
#
# if условие:
#
#     код блока if
#
# конец блока if

# Реальная ситуация: перед праздником в торговом центре объявили распродажу.
# При покупке электронных товаров вам предлагается скидка 20% при условии, что
# сумма покупки превышает 50 ООО. Клиент покупает некоторое количество товаров,
# суммарная стоимость купленных товаров вводится с клавиатуры. Нужно написать
# программу для вычисления суммы, подлежащей оплате

# #### total_amount= int (input("Oбщaя сумма nокуnаемых товаров : "))
# #### discount = 0
# #### if total_amount > 50000 :
# ####     discount = (total_amount * 20) /100
# #### bill_amount = total_amount - discount
# #### print(f"Итоговая сумма к оплате : {bill_amount} , скидка составила : {discount} ")

# 5.2.2. Оператор if-else
# В большинстве случаев бывает нужно что-то сделать, если условие if не выполни
# лось, т. е. оказалось ложно. Для этого у нас есть оператор if-else

# Как и ранее, оператор if проверяет условие: если условие истинно, запускается
# блок if, в противном случае выполняется другой блок операторов (называемый
# блоком else). При этом блок else не является обязательным.
#
# if условие :
#
#     код блока if
#
# else :
#
#     код блока else

nurn = int(input("Enter a number: "))
if nurn > 11:
    print(f"{nurn} i s greater than ")
else:
    print(f"{nurn} is smaller than 11")

# Реальная ситуация: перед праздником в торговом центре объявили распродажу.
# При покупке одежды и модных аксессуаров вам предлагается скидка 20% при
# условии, что сумма покупки превышает 25 ООО, в противном случае скидка состав
# ляет 5%. Клиент покупает некоторое количество товаров, суммарная стоимость
# купленных товаров вводится с клавиатуры. Напишите программу для вычисления
# суммы, подлежащей оплате.

# ##### full_suma = int(input("full suma of clothes and accessories purchased "))# общая сумма покупаемой одежды и аксессуаров
#
# ##### if full_suma > 25000:
# #####     discount_one = (full_suma * 20)/100
# #####     bill_amount_one = full_suma - discount_one
# #####     print(4"Итоговая сумма {bill_amount_one}, скидка составила {discount_one}")
#      pass
# #####
# ###### elif full_suma < 25000:
# ######     discount_two = (full_suma *5 )/100
# ######     bill_amount_two = full_suma - discount_two
# ######     print(f"Итоговая сумма {bill_amount_two}, скидка составила {discount_two}")

# 5.2.3. Оператор if-elif-else

x_entr = int(input("Please enter an integer :"))
if x_entr < 0:
    print("Negative NumЬer")
elif x_entr == 0:
    print("Zero")
elif x_entr == 1:
    print("Single")
else:
    print("More")

# Блоков elif может быть сколько угодно (или их может не быть вовсе), а блок else
# необязателен. Ключевое слово elif является сокращением от else if и позволяет
# избежать кода с огромными отступами.

# Реальная ситуация: в компании работают люди со всей страны. Отдел кадров
# классифицирует города по количеству населения на 3 категории: A, В и С. Размер
# компенсации аренды жилья зависит от класса города по следующим правилам: для
# города класса A - 30% от базовой заработной платы, для города класса B - 20%
# от базовой заработной платы, для города класса С - 10% от базовой заработной
# платы.

# ##### name = "Нилаб"
# ##### basic_salary = int(input(f"Зapплaтa сотрудника{name}"))
# ##### c ity_class = input()
# ##### if city_class == ( "a" or "A" ):
# #####     HRA_ONE = (basic_salary * 30) /100
# ##### print (f"Компенсация за аренду жилья для {name} составит{HRA_ONE}")
# ##### elif city_class == ( "b" or "В" ):
# #####     HRA_TWO = (basic_salary * 20) /100
# #####     print (f"Компенсация за аренду жилья для {name} составит{HRA_TWO}")
# ##### elif city_class == ("c" or "C" ) :
# #####     HRA_TREE = (basic_salary * 10) /100
# #####     print (f"Компенсация за аренду жилья для {name} составит{HRA_TREE}")

# 5.3. Оператор цикла for
#
# Циклы в программировании используются для многократного выполнения опреде
#
# ленного блока кода. Цикл for в Python выполняет итерацию по элементам передан
#
# ной последовательности (списка или строки) в том порядке, в котором они в этой
#
# последовательности представлены (рис. 5 .5). (Термин «итерация» означает повто
#
# рение процесса.)

# Нельзя не отметить простоту оператора for. Мы указываем переменную, которую
# хотим использовать (w или i в приведенных примерах), а затем используем опера
# тор in, чтобы связать переменную с последовательностью, которую мы хотим пере
# брать (здесь words - это наш список, т. е. последовательность).
# Обобщенно синтаксис выглядит следующим образом:
# for переменная in последовательность :
# код блок for

words = ["cat", "window"]
for w_i in words:
    print(w_i, len(w_i))

# 5.3.1 . Цикл for с блоком e/se
# В цикле for также может быть необязательный блок else. Блок else выполняется,
# когда элементы в последовательности, перебираемой циклом for, заканчиваются

# +
numbers = [1, 2, 3, 4]
for iteration in numbers:
    print(iteration)

print("This is end the code")
# -

# 5.4. Функция range()
# Если вам необходимо перебрать простую последовательность чисел, поможет
# встроенная функция range (). Она генерирует арифметическую прогрессию

# +
# Объявляем список для хранения чисел
integer_list: list[int] = []

# Используем другую переменную для цикла
for value_one in range(5):
    integer_list.append(value_one)
    # Добавляем текущее число в список

print(integer_list)  # Выводим список чисел
# -

#

# При этом последняя точка никогда не является частью сгенерированной последова
# тельности, например функция range (10) генерирует 10 значений, представляющщ
# собой допустимые индексы элементов последовательности длиной 10.
# Диапазон может начинаться с любого числа или иметь произвольный шаг (даже отрицатель
# ный), если это указать явно в параметрах функции:

# Для перебора элементов последовательности можно комбинировать функции
# range () И len ()

# checklist = ["Mary", "had", "little", "lamb"]
#
# for full_list in range(len(checklist)):
#
#     print(full_list, checklist[full_list])

checklist = ["Mary", "had", "little", "lamb"]
for index, item in enumerate(checklist):
    print(index, item)

print(list(range(10)))
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 5.5. Цикл while

# +
max_value = 10  # Максимальное значение для суммирования
summa = 0  # Переменная для хранения суммы
val_two = 1  # Начальное значение для суммирования

while val_two <= max_value:
    summa += val_two  # Суммируем текущее значение
    val_two += 1  # Увеличиваем значение на 1

print(f"The sum is {summa}")  # Выводим сумму
# -

# 5.6. Операторы break и continue
#
# 5.6. 1 . Оператор break

# Оператор break прерывает выполнение самого внутреннего цикла for или while.
#
# Операторы цикла могут иметь блок else, который выполняется, когда цикл завершается, перебрав все элементы (в случае цикла for) или когда условие становится ложным (в случае цикла while).
#
# Обратите внимание, что блок else не выполняется,
# когда цикл завершается оператором break

# +
numbers_one = [1, 2, 3, 4]

for inter in numbers_one:
    print(inter)
    break
else:
    print("this is end of the code")
print("This line outside the loop")
# -

# Вы заметили, что вместо 5 строк вывода, которые ранее печатал тот же цикл без
# оператора break, теперь выводится только одна строка в цикле? Дело в том, что
# оператор break остановил цикл for и не перевел его на следующую итерацию и про
# пустил блок else.

# В качестве примера возьмем цикл, который ищет простые числа:

for number_two in range(2, 10):
    # Цикл для проверки чисел от 2 до 9
    for divisor in range(2, number_two):
        # Проверяем делители от 2 до текущего числа
        if number_two % divisor == 0:
            # Если число делится на делитель без остатка
            print(
                number_two,
                "equals",
                divisor,
                "*",
                number_two // divisor,
            )  # Число не простое
            break  # Прерываем цикл, так как число не простое
    else:
        # Цикл завершён без нахождения делителя, число простое
        print(number_two, "is a prime number")

# 5.6.2. Оператор continue
# Оператор continue используется для пропуска части кода внутри цикла в пределах
# текущей итерации

# +
for alphabet in "python":
    if alphabet == "t":
        continue  # Пропустить итерацию, если символ "t"
    print(alphabet)

print("The end")  # Финальный вывод после завершения цикла
# -

for num_val in range(2, 10):
    if num_val % 2 == 0:  # четное число
        print("Found an even number", num_val)
        continue
    print("Found a number", num_val)

# 5.7. Оператор pass
#
# Оператор pass ничего не делает. Его можно использовать, когда
#
# в данном месте программы оператор синтаксически требуется, но
#
# никаких действий в этом местевыполнять не нужно.

# Обычно он используется для создания минимальных классов:
#
# class MyEmptyClass :
#
#     pass

# Еще его можно использовать в качестве заполнителя для функции или тела условия в момент написания нового кода. Эrо позволяет сначала набросать шаблон кода на
# более абстрактном уровне. Интерпретатором этот оператор просто игнорируется:

# def initlog ( *args ):
#
#     pass # не забудьте реализовать это !

item_value = 105
if item_value >= 100:
    print(f"Value of item_value is {item_value}")

current_number = 12
if current_number == 10:
    print("current_number is equal to 10")

# +
value_a = 90
value_b = 103

if value_a <= 100:
    print("Value of value_a is less than 100")
if value_b <= 100:
    print("Value of value_b is less than 100")
# -

#  Трейдер хочет, чтобы программа проверяла, получил ли он прибыль или убы
# ток по сделке. Напишите программу, в которой с клавиатуры вводится цена по
# купки и продажи, а в ответ программа сообщает, получил ли трейдер прибыль
# или убыток. Программа также должна рассчитать сумму прибыли или убытка

# +
# Запрос цены покупки и продажи у трейдера
purchase_price = float(input("Введите цену покупки: "))
selling_price = float(input("Введите цену продажи: "))

# Расчет прибыли или убытка
profit_loss = selling_price - purchase_price

# Проверка, есть ли прибыль или убыток
if profit_loss > 0:
    print(f"Трейдер получил прибыль в размере {profit_loss:.2f} единиц.")
elif profit_loss < 0:
    print(f"Трейдер понес убыток в размере {abs(profit_loss):.2f} единиц.")
else:
    print("Трейдер не получил ни прибыли, ни убытка.")
# -

# Формат .2f используется в Python для форматирования чисел с плавающей запятой. Он указывает, что число должно быть представлено с двумя знаками после десятичной точки. Давайте разберем это более подробно.
#
#
#
# value = 123.456789
#
# print(f"Значение: {value:.2f}")  # Вывод: Значение: 123.46
#
# Объяснение:
#
#     . — точка, которая указывает на начало дробной части числа.
#
#     2 — количество знаков после десятичной точки, которые вы хотите отобразить.
#
#     f — обозначает, что число будет в формате с плавающей запятой (floating point).
#

# +
value_f = 123.456789

print(f"Значение: {value_f:.5f}")  # Вывод: Значение: 123.46
# -

# Функция abs() в Python используется для вычисления абсолютного значения числа. Абсолютное значение — это значение числа без его знака. Например, абсолютное значение как положительных, так и отрицательных чисел всегда будет неотрицательным.
#
#
# print(abs(-5))  # Вывод: 5
#

# +
complex_number = 3 + 4j
print(abs(complex_number))

# Вывод: 5.0 (это длина вектора в комплексной плоскости)
# -

# def calculate_profit_or_loss(purchase: float, selling: float) -> None:
#     """
#     Функция для вычисления прибыли или убытка от сделки.
#
#     :param purchase: цена покупки.
#     :param selling: цена продажи.
#     """
#     profit_or_loss = selling - purchase
#
#     if profit_or_loss > 0:
#         print(f"Трейдер получил прибыль в размере {profit_or_loss:.2f} единиц.")
#     elif profit_or_loss < 0:
#         print(f"Трейдер понес убыток в размере {abs(profit_or_loss):.2f} единиц.")
#     else:
#         print("Трейдер не получил ни прибыли, ни убытка.")
#
#
# # Ввод данных от пользователя
# try:
#     purchase_input = float(input("Введите цену покупки: "))
#     selling_input = float(input("Введите цену продажи: "))
#     calculate_profit_or_loss(purchase_input, selling_input)
# except ValueError:
#     print("Пожалуйста, введите корректные числовые значения.")


# +
def is_leap(year: int) -> bool:
    """Проверяет, является ли год високосным."""
    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)


try:
    # Запрашиваем год у пользователя
    year_input = int(input("Введите год: "))

    # Проверяем, является ли год високосным
    if is_leap(year_input):
        print(f"Год {year_input} является високосным.")
    else:
        print(f"Год {year_input} не является високосным.")
except ValueError:
    print("Пожалуйста, введите корректное целое число.")
# -

# Функция is_leap_year:
#
#     Принимает целое число year и возвращает True, если год является високосным, и False в противном случае.
#     Високосный год — это год, который делится на 4, но не делится на 100, за исключением годов, которые делятся на 400.

# Трое сотрудников, Самир, Правин и Мохит, вводят свой опыт работы с клавиа
# туры. Напишите программу, которая определяет наиболее и наименее опытного
# из них

# def main() -> None:
#     """Основная функция для определения.
#
#     наиболее и наименее опытного сотрудника.
#
#     """
#     # Запрашиваем опыт работы у каждого сотрудника
#     samir_experience = float(input("Введите опыт работы Самир в годах: "))
#     pravin_experience = float(input("Введите опыт работы Правин в годах: "))
#     mohit_experience = float(input("Введите опыт работы Мохит в годах: "))
#
#     # Создаем словарь для хранения имен сотрудников и их опыта
#     experience_dict = {
#         "Самир": samir_experience,
#         "Правин": pravin_experience,
#         "Мохит": mohit_experience,
#     }
#
#     # Находим наиболее и наименее опытного сотрудника с помощью лямбда-функции
#     most_experienced = max(experience_dict, key=lambda name: experience_dict[name])
#     least_experienced = min(experience_dict, key=lambda name: experience_dict[name])
#
#     # Вывод результатов
#     print(
#         f"Наиболее опытный сотрудник: {most_experienced} "
#         f"с опытом {experience_dict[most_experienced]} лет."
#     )
#     print(
#         f"Наименее опытный сотрудник: {least_experienced} "
#         f"с опытом {experience_dict[least_experienced]} лет."
#     )
#
#
# if __name__ == "__main__":
#     main()

# Выражение key=lambda name: experience_dict[name] используется в функциях max() и min() для определения правила сравнения значений в словаре. Это нужно для того, чтобы функции знали, по какому критерию выбирать максимальное или минимальное значение. Давайте разберем это подробнее.

#
# Лямда-функции в Python — это анонимные функции, которые могут быть созданы "на лету". Они используются, когда нужно создать простую функцию без необходимости явно определять её с помощью def
#
# experience_dict[name]:
#
#     Это возвращаемое значение лямбда-функции. Для каждого ключа (имени сотрудника) она возвращает значение, соответствующее этому ключу, то есть количество лет опыта данного сотрудника. Внутри словаря experience_dict ключи — это имена сотрудников, а значения — их опыт.

# most_experienced = max(experience_dict, key=experience_dict.get)
# least_experienced = min(experience_dict, key=experience_dict.get)
#
# max(iterable, key): функция возвращает наибольший элемент из итерируемого объекта (в данном случае, из словаря). Здесь iterable — это experience_dict, а key — это функция, которая определяет, как сравнивать элементы.
#
#
# min(iterable, key): функция возвращает наименьший элемент из итерируемого объекта
#
# key=experience_dict.get:
#
#     Здесь используется метод get словаря, который позволяет получить значение, соответствующее ключу. В данном случае, experience_dict.get будет возвращать опыт работы (число) для каждого сотрудника.
#     Когда мы передаем experience_dict.get в max() или min(), мы говорим функции, что мы хотим находить максимум или минимум по значениям (опыту) словаря, а не по ключам (именам сотрудников).
