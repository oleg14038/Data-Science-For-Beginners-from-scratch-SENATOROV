"""The module typing need for iteration."""

from collections.abc import Iterator

# Функции 6

# 6.1 . Определение функций

# В Python функция - это группа связанных операторов, выполняющих определен
# ную задачу

# 6.2. Типы функций
#
# Встроенные функции уже определены в Python и могут быть вызваны напря
# мую.
#
# Пользовательские функции - это объекты, которые создаются пользователем
# с помощью явного определения. Функция вызывается с тем же количеством ар
# гументов, что и в формальном описании функции

# список встроенн��х функций Python по алфавиту:
#
#     abs() — Возвращает абсолютное значение числа.
#
#     all() — Возвращает True, если все элементы итерируемого объекта истинны
# (или если итерируемый объект пуст).
#
#     any() — Возвращает True, если хотя бы один элемент итерируемого объекта
# истинный.
#
#     ascii() — Возвращает строковое представление объекта, содержащего только
# ASCII-символы.
#
#     bin() — Преобразует целое число в двоичное представление.
#
#     bool() — Преобразует значение в булевое (логическое) значение True или
# False.
#
#     breakpoint() — Включает встроенную отладку в точке вызова.
#
#     bytearray() — Возвращает объект массива байтов.
#
#     bytes() — Возвращает объект bytes.
#
#     callable() — Проверяет, является ли объект вызываемым (может ли он
# быть вызван как функция).
#
#     chr() — Преобра��ует код Unicode в соответствующий символ.
#
#     classmethod() — Преобразует метод в метод класса.
#
#     compile() — Компилирует исходный код в объект кода.
#
#     complex() — Создаёт комплексное число.
#
#     delattr() — Удаляет атрибут объекта.
#
#     dict() — Создаёт словарь.
#
#     dir() — Возвращает список атрибутов и методов объекта.
#
#     divmod() — Возвращает частное и остаток от деления.
#
#     enumerate() — Возвращает итератор с индексами и элементами.
#
#     eval() — Выполняет строку как выражение Python.
#
#     exec() — Выполняет строку как код Python.
#
#     filter() — Возвращает итератор с отфильтрованными элементами
# итерируемого объекта.
#
#     float() — Преобразует значение в число с плавающей запятой.
#
#     format() — Форматирует строку.
#
#     frozenset() — Возвращает неизменяемое множество.
#
#     getattr() — Возвращает значение атрибута объекта.
#
#     globals() — Возвращает словарь глобальных переменных.
#
#     hasattr() — Проверяет, имеет ли объект указанный атрибут.
#
#     hash() — Возвращает хеш-значение объекта.
#
#     help() — Вызов встроенной системы помощи.
#
#     hex() — Преобразует целое число в шестнадцатеричное представление.
#
#     id() — Возвращает уникальный идентификатор объекта.
#
#     input() — Принимает ввод от пользователя.
#
#     int() — Преобразует значение в целое число.
#
#     isinstance() — Проверяет, является ли объект экземпляром указанного
# класса.
#
#     issubclass() — Проверяет, является ли класс подклассом другого класса.
#
#     iter() — Возвращает итератор объекта.
#
#     len() — Возвращает длину объекта.
#
#     list() — Преобразует объект в список.
#
#     locals() — Возвращает словарь локальных переменных.
#
#     map() — Применяет функцию к каждому элементу итерируемого объекта.
#
#     max() — Возвращает максимальный элемент итерируемого объекта.
#
#     memoryview() — Возвращает объект памяти.
#
#     min() — Возвращает минимальный элемент итерируемого объекта.
#
#     next() — Возвращает следующий элемент итератора.
#
#     object() — Возвращает новый объект.
#
#     oct() — Преобразует целое число в восьмеричное представление.
#     open() — Открывает файл и возвращает файловый объект.
#
#     ord() — Возвращает код символа Unicode.
#
#     pow() — Возводит число в степень.
#
#     print() — Выводит данные на экран.
#
#     property() — Возвращает объект свойства.
#
#     range() — Возвращает последовательность чисел.
#
#     repr() — Возвращает строковое представле��ие объекта.
#
#     reversed() — Возвращает обратный итератор.
#
#     round() — Округляет число до указанного количества знаков.
#
#     set() — Создаёт множество.
#
#     setattr() — Устанавливает атрибут объекта.
#
#     slice() — Возвращает объект среза.
#
#     sorted() — Возвращает отсортированный список.
#
#     staticmethod() — Преобразует метод в статический метод.
#
#     str() — Преобразует объект в строку.
#
#     sum() — Возвращает сумму элементов итерируемого объекта.
#
#     super() — Возвращает объект родительского класса.
#
#     tuple() — Преобразует объект в кортеж.
#
#     type_color() — Возвращает тип объекта.
#
#     vars() — Возвращает словарь атрибутов объекта.
#
#     zip() — Объединяет элементы нескольких итерируемых объектов.
#
#     import() — Импортирует модуль по его имени.

# abs()
#
# Во��в��ащает абсолютное значение числа
#
# print(abs(-5))  # Вывод: 5
#
# Аргумент может быть целым числом или числом с плавающей точкой. Если аргумент
#
# комплексное число, возвращается его абсолютное значение

# all()
#
# Возвращает True, если все элементы итерируемого объекта истинны
#
# print(all([True, True, False]))
#
# Вывод: False
#

# any()
#
# Возвращает True, если хотя бы один элемент итерируемого объекта истинный
#
# print(any([False, True, False]))  # Вывод: True
#
# Если итерируемый объект пуст, возвращается False.

# ascii()
#
# Возвращает строковое представление объекта, содержащего только ASCII-символы.
#
# print(ascii("Привет"))  # Вывод: '\u041f\u0440\u0438\u0432\u0435\u0442'
#

# bin()
#
# Преобразует целое число в двоичное представление.
#
# print(bin(10))  # Вывод: '0b1010'
#

# bool()
#
# Преобразует значение в булевое значение True или False
#
# print(bool(0))  # Вывод: False
#

# breakpoint()
#
# Включает встроенную отладку в точке вызова
#
# breakpoint()  # Откроет интерактивную отладку.
#

# bytearray()
#
# Возвращает объект массива байтов
#
# print(bytearray(4))  # Вывод: bytearray(b'\x00\x00\x00\x00')
#

# bytes()
#
# Возвращает объект bytes.
#
# print(bytes(4))  # Вывод: b'\x00\x00\x00\x00'
#

#  callable()
#
# Проверяет, является ли объект вызываемым (как функция).
#
# print(callable(print))  # Вывод: True
#
#  chr()
#
# Преобразует код Unicode в символ.
#
# print(chr(97))  # Вывод: 'a'
#
# chr (i) возвращает строку, представляющую собой символ, кодировка которого
#
# в таблице Unicode равна i. Например, chr (97) возвращает строку  'а',
# а chr(8 364)
#
# возащает строку ' € ' . Функция обратна функции ord ( )
#
# classmethod()
#
# Преобразует метод в метод класса.
#
# class MyClass:
#     @classmethod
#     def my_class_method(cls):
#         print(f"Called from {cls}")
#
# MyClass.my_class_method()  # Вывод: Called from <class '__main__.MyClass'>
#
# compile()
#
# Компилирует исходный код в объект кода.
#
# print(complex(1, 2))  # Вывод: (1+2j)
#
# delattr()
#
# Удаляет атрибут объекта.
#
# class MyClass:
#     x = 10
#
# obj = MyClass()
# delattr(obj, 'x')

#  dict()
#
# Создаёт словарь.
#
# print(dict(a=1, b=2))  # Вывод: {'a': 1, 'b': 2}

# dir()
#
# Возвращает список атрибутов и методов объекта.
#
# print(dir([]))  # Вывод: ['append', 'clear', 'copy', ...]
#
#
# dir ([oЬjectJ]) при вызове без аргумента возвращает список имен всех
# локальных
#
# объектов. С аргументом возвращает список допустимых атрибутов для передан
#
# ного объекта

# divmod()
#
# Возвращает частное и остаток от деления.
#
# print(divmod(9, 2))  # Вывод: (4, 1)

# enumerate()
#
# Возвращает итератор с индексами и элементами
#
# for index, value in enumerate(['a', 'b', 'c']):
#
#     print(index, value)
# Вывод:
#
# 0 a
#
# 1 b
#
# 2 c
#

# eval()
#
# Выполняет строку как выражение Python.
#
# print(eval('1 + 2'))  # Вывод: 3
#

#  exec()
#
# Выполняет строку как код Python.
#
# exec('x = 5; print(x)')  # Вывод: 5
#

# filter()
#
# Возвращает итератор с отфильтрованными элементами
#
# print(list(filter(lambda x: x > 0, [-1, 0, 1, 2])))  # Вывод: [1, 2]
#

# . float()
#
# Преобразует значение в число с плавающей запятой.
#
# print(float("3.14"))  # Вывод: 3.14
#

# format()
#
# Форматирует строку.
#
# print("{:.2f}".format(3.14159))  # Вывод: 3.14
#
# frozenset()
#
# Возвращает неизменяемое множество.
#
# fs = frozenset([1, 2, 3])
#
# print(fs)
#
# Вывод: frozenset({1, 2, 3})
#

# getattr()
#
# Возвращает значение атрибута объекта.
#
# class MyClass:
#
#     x = 10
#
# obj = MyClass()
#
# print(getattr(obj, 'x'))  # Вывод: 10
#

# globals()
#
# Возвращает словарь глобальных переменных.
#
# print(globals())  # Выводит глобальные переменные.
#

# hasattr()
#
# Проверяет, имеет ли объект указанный атрибут.
#
# class MyClass:
#     x = 10
#
# obj = MyClass()
# print(hasattr(obj, 'x'))  # Вывод: True
#

# hash()
#
# Возвращает хеш-значение объекта.
#

# print(hash("test"))  # Вывод: хеш-значение
#

# help()
#
# Вызывает встроенную систему помощи.
#
# help(print)  # Выводит справку о функции print.
#

# hex()
#
# Преобразует целое число в шестнадцатеричное представление
#
# print(hex(255))  # Вывод: '0xff'
#

# id()
#
# Возвращает уникальный идентификатор объекта.
#
# print(id(123))  # Вывод: уникальный идентификатор объекта
#

# input()
#
# Принимает ввод от пользователя
#
# name = input("Введите ваше имя: ")
#
# print(name)
# int()
#
# Преобразует значение в целое число.
#
# print(int("10"))  # Вывод: 10
#

# isinstance()
#
# Проверяет, является ли объект экземпляром указанного класса.
#
# print(isinstance(10, int))  # Вывод: True
#
#
# isinstance (oЬject, classinfo) возвращает True, если аргумент object является
#
# экземпляром класса classinfo или его подклассом (прямым, косвенным или вирту
#
# альным). Если объект не является объектом данного типа, функция возвращает
#
# False.

# issubclass()
#
# Проверяет, является ли класс подклассом другого класса
#
# class A: pass
#
# class B(A): pass
#
# print(issubclass(B, A))  # Вывод: True
#
#

# . iter()
#
# Возвращает итератор объекта.
#
# it = iter([1, 2, 3])
#
# print(next(it))  # Вывод: 1
#

#  len()
#
# Возвращает длину объекта.
#
# print(len([1, 2, 3]))  # Вывод: 3
#

# list()
#
# Преобразует объект в список.
#
# print(list("abc"))  # Вывод: ['a', 'b', 'c']
#
#

# locals()
#
# Возвращает словарь локальных переменных.
#
# def func():
#
#     x = 10
#
#     print(locals())
#
# func()
#
#
# {'x': 10}
#

# map()
#
# Применяет функцию к каждому элементу итерируемого объекта.
#
# print(list(map(lambda x: x**2, [1, 2, 3])))  # Вывод: [1, 4, 9]
#

# max()
#
# Возвращает максимальный элемент.
#
# print(max([1, 2, 3]))  # Вывод: 3
#

# memoryview()
#
# Возвращает объект памяти.
#
# b = bytearray('abc', 'utf-8')
#
# mv = memoryview(b)
#
# print(mv[0])  # Вывод: 97
#
#

# min()
#
# Возвращает минимальный элемент.
#
# print(min([1, 2, 3]))  # Вывод: 1
#
#

# next()
#
# Возвращает следующий элемент итератора.
#
# it = iter([1, 2, 3])
#

# open (file) открывает файл и возвращает соответствующий файловый объект

# ord(c) принимает строку, состоящую из одного символа Unicode, и возвращает
#
# целое число, представляющее код Unicode этого символа. Например, ord ( ' а
# ' )
#
# возвращает 97, а ord ( ' € ' ) возвращает вз 64. Функция обратна chr ( )

# repr (oЬjects) возвращает строку, содержащую формальное строковое представ
# ление объекта

# reversed(seq) возвращ��ет итератор в обратном порядке

# round(m.пaЬer [ , ndigits] ) округляет число с точностью до ndigits знаков
#
# после десятичной точки. Если аргумент ndigi ts опущен или равен None, функция
#
# возвращает ближайшее целое.

# 6.4.2. Создание и вызов функций

# Как и у всего остального, у создания (определения) функций есть собственный
# синаксис. Он весьма прост:
#
# def имя_функции ( ) :
#
#     тело_функции

# Когда мы пишем оператор def, интерпретатор Python понимает, что мы собираемся
#
# определить функцию. Совершенно очевидно, что «def» - это сокращение от англ.
#
# define (определять). Теперь мы должны дать нашей функции уникальное имя. По
#
# сле слова def следует имя функции, затем пара круглых скобок ()идвоеточие(:).
#
# В следующей строке идет тело функци��. Оно начинается с отступа, который сооб
#
# щает Python, что этот блок кода является телом функции. Тело функции - это не
#
# что иное, как код, который функция выполняет

# Имя, которое мы даем нашей функции, должно быть уникальным, как и перемен
#
# ные. М ы можем назвать нашу функцию как угодно, но необходимо при этом
#
# соблюдать правила языка Python. Кроме того, функцию следует наделять таким
#
# именем, которое связано с ее назначением, т. е. имеет смысл.
# Это поможет другим
#
# программистам, читающим ваш код, легко понять, для чего она предназначена.
#
# Давайте определим простую функцию, чтобы быстрее освоить новую концепцию.
#
# In [ 1 ] : def greeting ( ) :
#
# print ( "Good Morning")

# def greeting():
#
#     print("Good Morning")
#
# greeting()

# def Lamonade(price)-> None:
#
#     if (price == 5):
#
#         print()
#
# Переменная price, которая указана в круглых скобках в определении функции,
#
# называется параметром функции.

# def lemonade_stall(price: int) -> None:
#
#     """Проверяет цену и выводит ингредиенты напитков в зависимости
# от стоимости."""
#
#     if price == 5:
#         print("Лимонад сделан из:")
#
#         print("Лимонный сок")
#
#         print("Вода")
#
#         print("Соль")
#
#         print("Сахар")
#
#         print("\nSprite сделан из:")
#
#         print("Лимонный сок")
#
#         print("Содовая")
#
#         print("Сахар")
#
#         print("Секретный ингредиент")
#     else:
#
#         print("Пожалуйста, заплатите нужную сумму.")
#
# lemonade_stall()
#
# TypeError : Lemonade Stall ( ) missing 1 required positional argument :
# ' price '

# Аргумент - это значение, которое мы присваиваем параметру при вызове функ
# ции. Вызываемая нами функция запуталась, т. к. у функции есть параметр, но мы
# не задали для него значение при вызове функции.


# +
def lemonade_stall(price: int) -> None:
    """Проверяет цену.

    Выводит:. Ингредиенты напитков в зависимости от стоимости.
    """
    if price == 5:
        print("Лимонад сделан из:")
        print("Лимонный сок")
        print("Вода")
        print("Соль")
        print("Сахар")

        print("\nSprite сделан из:")
        print("Лимонный сок")
        print("Содовая")
        print("Сахар")
        print("Секретный ингредиент")
    else:
        print("Пожалуйста, заплатите нужную сумму.")


lemonade_stall(5)

# Параметр - это переменная, указанная в скобках в определении функции
#
# А аргумент - это значение, которое передается в функцию при ее вызове:


# 6.4.3.3. Количество аргументов
# Когда вы вызываете функцию, ей нужно передать правильное количество аргумен
# тов. То есть если у функции определены 2 параметра, вы должны передать ей
# 2 аргумента, не бо��ьше и не меньше.
# +
def my_name(first_name: str, last_name: str) -> None:
    """Функция выводит полное имя.

    :param first_name: Имя. :param last_name: Фамилия.
    """
    print(f"Ваше имя: {first_name} {last_name}")


# Вызов функции
my_name("Oleg", "Nefedov")


# +
def fib(max_value: int) -> None:
    """Выводит ряд Фибоначчи до числа max_value."""
    first, second = 0, 1
    while first < max_value:
        # вывод ряда Фибоначчи до max_value
        print(first, end=" ")
        first, second = second, first + second
    print()  # добавляет перевод строки в конце


# Вызовем функцию, которую мы только что определили
fib(100)

# Возвращаемое значение - это не то значение, которое выводится на экран. По
# скольку определение функции не содержит оператора return, функция возвращает
# значение None. Вывод на экран значения None обычно игнорируется интерпретато
# ром, если это единственное выводимое значение. Это легко продемонстрировать
# С ПОМОЩЬЮ функции print () .

# Оператор return возвращает значение из функции. Если после оператора return
# ничего не указать, возвращается None. Если этот оператор отсутствует в конце
# функции, тоже возвращается None.

# В выражении result . append (a) вызывается метод списка result. Метод - это
# функция, которая «принадлежит» объекту и определяется типом объекта. Раз
# ные типы объектов имеют разные методы. Метод append ( ) в нашем примере
# определен для списков и добавляет новый элемент в конец списка. Это эквива
# лентно выражению result = result + [ а ] , но более эффективно.

# Метод — это функция, связанная с объектом. В Python тип объекта определяет,
# какие методы доступны для использования

# В Python существует четыре основных способа передачи аргументов в функцию,
# и их можно комбинировать. Эти варианты позволяют передавать аргументы гибким
# образом и обеспечивают возможность работы с разным количеством и типами
# аргументов.

# 1. Позиционные аргументы (Positional arguments)
#
# Аргументы передаются в функцию в порядке их объявления. Эти аргументы
# обязательны, и порядок имеет значение


# +
def greet(name: str, age: int) -> None:
    """Выводит приветствие с именем и возрастом.

    :param name: Имя человека. :param age: Возраст человека.
    """
    print(f"Привет, {name}. Тебе {age} лет.")


# Вызов функции с позиционными аргументами
greet("Олег", 30)

# 2. Именованные аргументы (Keyword arguments)
#
# Аргументы передаются по имени. В этом случае порядок ��е имеет значения,
# так как аргументы явно указаны.

# def greet(name, age):
#
#     print(f"Привет, {name}. Тебе {age} лет.")
#
# greet(name="Олег", age=30)  # Именованны�� аргументы
#
# greet(age=30, name="Олег")  # Порядок не важен
#

# 3. Произвольное количество позиционных аргументов (*args)
#
# С помощью *args можно передавать функции переменное количество позиционных
# аргументов. Все переданные аргументы собираются в кортеж.
# +


def print_numbers(*args: int) -> int:
    """Выводит заданные числа.

    :param args: Произвольное количество чисел.
    """
    for number in args:
        print(number)
    return sum(args)


# Вызов функции с передачей произвольного количества аргументов
print_numbers(1, 2, 3, 4, 5)


# 4. Произвольное количество именованных аргументов (**kwargs)
#
# С помощью **kwargs можно передавать функции произвольное количество
# именованных аргументов. Все переданные аргументы собираются в словарь.
# +


def print_info_data(**user_details: str) -> None:
    """Print information about the provided keyword arguments."""
    for key, value in user_details.items():
        print(f"{key}: {value}")


# Calling the function with keyword arguments
print_info_data(
    user_name="Oleg",
    user_age="30",
    user_city="Moscow",
)  # Passing keyword arguments


# Комбинирование аргументов
# Вы можете комбинировать различные виды аргументов в одной функции.
# При этом следует соблюдать порядок: сначала идут позиционные аргументы,
# затем *args, затем именованные аргументы, и только потом **kwargs.


# +
def full_greet(greeting: str, *args: str, **kwargs: str) -> None:
    """Print a greeting followed by positional and keyword arguments."""
    print(greeting)

    print("Positional arguments (args):")
    for arg in args:
        print(arg)

    print("Keyword arguments (kwargs):")
    for key, value in kwargs.items():
        print(f"{key}: {value}")


def print_info(**user_details: str) -> None:
    """Print information about the provided keyword arguments."""
    for key, value in user_details.items():
        print(f"{key}: {value}")


# Now, we can call the functions correctly
print_info(user_name_name="Oleg", user_full_age="30", user_city_live="Moscow")


full_greet("Hello!", "Oleg", "Ivan", age=str(30), city="Moscow")

# 6.5.3. Именованные аргументы


def parrot(
    volt: int | float,
    state: str = "dead",
    act: str = "comes_to_life",
    type_color: str = "Norwegian Blue",
) -> None:
    """Функция выводит информацию о попугае в.

    зависимости от состояния и напряжения.

    :param volt: Напряжение (обязательный параметр). :param state: Состояние
    попугая (по умолчанию 'dead'). :param act: Действие попугая (по умолчанию
    'comes_to_life'). :param type_color: Тип попугая (по умолчанию 'Norwegian
    Blue')
    """
    print("- Это попугай не", act, end=" ")
    print("Even if you skip it", volt, "volt through it")
    print("-What plumage!", type_color)
    print("He", state, "!")


# 1. Позиционный аргумент
parrot(1000)

# 2. Именованный аргумент
parrot(volt=1000)

# 3. Два именованных аргумента
parrot(volt=1000000, act="It will fly")

# 4. Два именованных аргумента в другом порядке
parrot(act="It will fly", volt=1000000)

# 5. Три позиционных аргумента (обратите внимание,
# что функции паррот не хватает
# кода, чтобы обработать больше трех параметров.
# Предположим, что паррот
# ожидает до 4-х параметров)
parrot(10000, "went to the forefathers", "will jump")

# 6. Один позиционный и один именованный аргумент
parrot(100000, state="flying with angels")

# 7. Ошибка: отсутствует обязательный аргумент `volt`
# parrot()  # это вызовет ошибку TypeError,
# потому что `volt` обязательный

# 8. Ошибка: неименованный аргумент после именованного
# parrot(volt=5.0, "He died")  # Это вызовет ошибку синтаксиса.
# Нельзя передавать неименованный аргумент после именованного.

# 9. Ошибка: передача одно��о и того же аргумента дважды
# parrot(110, volt=220)
# # Это вызовет ошибку, потому что аргумент `volt` передается дважды


# 10. Ошибка: неизвестный именованный аргумент
# parrot(act="Jgon KLiz")  # Это вызовет ошибку,
# если `act` не является ожидаемым аргументом.
# Это не ошибка синтаксиса, но логическая ошибка,
# если аргумент `act` не предусмотрен.
# +
def try_function(*args: str, **kwargs: str | int) -> None:
    """Функция принимает произвольное количество позиционных.

    именованных аргументов.

    :param args: Позиционные аргументы.
    которых является строкой.
    :param kwargs: Именованные аргументы, где ключи - строки.
      значения могут быть строками или числами.
    """
    print("args:", args)  # args будет кортежем строк
    print("kwargs:", kwargs)


# kwargs будет словарем, где ключи - строки, а значения - строки или числа
# Вызов функции с правильным использованием *args и **kwargs
try_function(
    "Monday",
    "Tuesday",
    "Wednesday",  # Позиционные аргументы (строки)
    fourth="Thursday",
    fifth="Friday",
    weekend1="Saturday",
    weekend2="Sunday",
    year=2024,
)  # Именованные аргументы (ключи - строки, значения - строки или числа)

# 6.6. Генераторы

# Генератор - это функция, возвращающая итератор. То есть эти функции
# генерируют объект, который можно перебирать в цикле.
# Генератор - это особый класс функций. Вместо того, чтобы возвращать одно
#  значение, функция-генератор возвращает последовательность значений
# ( объектитератор ). Слово return в таких функциях заменяется на yield.
#  Рассмотрим это подробнее.


def inclusive_range(*args: int) -> Iterator[int]:
    """Функция, которая генерирует последовательность.

    чисел от start до stop с шагом step.


    :param args: Позиционные аргументы.
     - 1 аргумент: stop (до этого значения, не включая).
     - 2 аргумента: start и stop.
     - 3 аргумента: start, stop, и step.
    :return: Итератор, генерирующий числа от start до stop с шагом step.
    """
    numargs = len(args)

    # начальные значени
    start = 0
    step = 1

    # проверка параметров
    if numargs < 1:
        raise TypeError(f"Expected at least one argument, got {numargs}")
    if numargs == 1:
        stop = args[0]
    if numargs == 2:
        start, stop = args
    if numargs == 3:
        start, stop, step = args
    else:
        raise TypeError(f"Expected at most 3 arguments, got {numargs}")

    # генератор
    i = start
    while i <= stop:
        yield i
        i += step


# В Python items() — это метод, который используется для получения
# представления элементов словаря. Он возвращает представление, состоящее из
# пар ключ-значение, которые могут быть перебраны в цикле
